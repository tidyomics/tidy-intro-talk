---
title: "Tidy Intro Talk"
author: "Michael Love"
format: html
highlight-style: oblivion
editor: visual
---

## Tidyomics project

An open, open-source project spanning multiple R packages, and
developers from around the world. Organized as a GitHub organization
with GitHub Projects. For more:

-   <https://github.com/tidyomics>

-   <https://www.biorxiv.org/content/10.1101/2023.09.10.557072v2>

-   `tidiness_in_bioc` channel in Bioconductor Slack

## Diagram of the tidyomics project

![](figures/figure2.png)

## Objects keep data organized

-   We typically have more information than just a matrix

-   Row and column information (on features and samples)

-   Metadata on organism, genome build, annotation release, etc.

-   Keeping this information altogether is the motivation for *data
    objects*

-   Many functions in Bioconductor are *endomorphic* meaning that an
    object is passed in, some data may be added/modified, then the
    object is passed back out

I will first introduce one of the main data objects in Bioconductor, the
*SummarizedExperiment*.

After introducing this, I'll motivate `tidyomics` as applied to
Bioconductor objects.

A *SummarizedExperiment* is built from three tables, which I will
demonstrate now:

```{r}
#| message: false
library(SummarizedExperiment)
# metadata about genes
genes <- DataFrame(
  id = c("g1","g2","g3","g4"), 
  symbol = c("ABC","DEF","GHI","JKL")
  )
genes
```

```{r}
# metadata about samples
samples <- DataFrame(
  sample = c("s1","s2","s3","s4"),
  condition = c("x","y","x","y"),
  sex = c("m","m","f","f")
  )
samples
```

```{r}
set.seed(123) # we will generate some random count data
counts <- matrix(rpois(16, lambda=100), ncol=4)
rownames(counts) <- genes$id
colnames(counts) <- samples$sample
counts
```

```{r}
se <- SummarizedExperiment(
  assays = list(counts = counts),
  rowData = genes, 
  colData = samples,
  metadata = list(organism="Hsapiens")
  )
se
```

## Avoid common bookkeeping errors

Reordering samples (columns) is a global operation:

```{r}
se2 <- se[,c(1,3,2,4)]
assay(se2, "counts")
colData(se2)
```

Assignment that might result in sample swap results in an error:

```{r}
#| eval: false
assay(se2) <- counts
# Error:
# please use 'assay(x, withDimnames=FALSE)) <- value' or 
# 'assays(x, withDimnames=FALSE)) <- value'
# when the rownames or colnames of the supplied assay(s) are not 
# identical to those of the receiving  SummarizedExperiment object 'x'
```

Other such validity checks include comparison of genomic ranges across
different genome builds: will result in an error.

## Can be hard for new users

```{r}
slotNames(se)
methods(class = class(se))
```

## Many beginners know `dplyr`/`ggplot2`

```{r}
#| message: false
library(dplyr)
# filter to samples in condition 'x'
samples |> 
  as_tibble() |> 
  filter(condition == "x")
```

## Enabling dplyr verbs for omics

```{r}
#| message: false
library(tidySummarizedExperiment)
se
```

What does this mean "*SE-tibble abstraction*"?

...put a drawing...

## Still a standard Bioc object

```{r}
class(se)
dim(se)
```

## We can use familiar dplyr verbs

```{r}
se |> 
  filter(condition == "x")
```

```{r}
se_sub <- se |> 
  filter(condition == "x")
colData(se_sub)
```

## Facilitates quick exploration

```{r}
#| message: false
#| echo: false
library(ggplot2)
theme_set(theme_grey(base_size = 16))
```

```{r ggplot}
#| message: false
library(ggplot2)
se |> 
  filter(.feature %in% c("g1","g2")) |> 
  ggplot(aes(condition, counts, color=sex, group=sex)) + 
  geom_point(size=2) + 
  geom_line() +
  facet_wrap(~.feature) +
  ylim(0,200)
```

```{r}
#| echo: false
options(dplyr.summarise.inform=FALSE)
```

```{r grouping-genes}
# suppose we had gene groups
rowData(se)$gene_group = c(1,1,2,2)
se |> 
  group_by(gene_group, condition, sex) |> 
  summarize(ave_count = mean(counts), sd_count = sd(counts)) |> 
  ggplot(aes(condition, ave_count, 
             ymin=ave_count - 2*sd_count, 
             ymax=ave_count + 2*sd_count,
             color=sex, group=sex)) + 
  geom_pointrange(position = position_dodge(width = .25)) + 
  facet_wrap(~gene_group, labeller = "label_both") +
  ylim(0,200)
```

## Also works with Seurat and SCE

*SingleCellExperiment* = *SummarizedExperiment* with extra bells and
whistles for single cells. E.g. slots for reduced dimensions.

```{r umap}
#| message: false
library(tidySingleCellExperiment)
# data from tidyomics/tidyomicsWorkshopBioc2023
sce <- readRDS("data/tidyomicsWorkshopSCE.rds")
# SCE is slightly different than SE, more cell focused
sce |>
  filter(Phase == "G1") |>
  mutate(log10count = log10(nCount_RNA)) |>
  ggplot(aes(UMAP_1, UMAP_2, color=log10count)) +
  geom_point()
```

```{r}
# can include and compute on gene expression values
sce |>
  join_features(c("CD3D","TRDC"), shape="wide") |>
  select(.cell, CD3D, TRDC)
```

```{r}
# process the sample ID from the filename
sce |>
  extract(file, "sample", "../data/.*/([a-zA-Z0-9_-]+)/outs.+") |>
  select(sample)
# aggregate across sample = pseudobulking, returns SE
sce |>
  extract(file, "sample", "../data/.*/([a-zA-Z0-9_-]+)/outs.+") |>
  aggregate_cells(sample)
```

## Genomic overlaps are joins

## Matching and bootstrapping

e.g. find the sum of peak score within TAD

## Limitations

-   package code and *non-standard evaluation*
-   optimized code, e.g. matrix operations

## Outro

Recommend students/analysts are always checking:

-   main contributions to variance (e.g. PCA)
-   column and row densities
-   known positive features, feature-level plots
