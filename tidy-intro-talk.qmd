---
title: "Tidy Intro Talk"
author: "Michael Love"
format: html
highlight-style: oblivion
editor: visual
---

## Data objects keep data organized

-   We typically have more information than just a matrix

-   Row and column information (on features and samples)

-   Metadata on organism, genome build, annotation release, etc.

-   Keeping this information altogether is the motivation for *data
    objects*

I will first introduce one of the main data objects in Bioconductor,
the *SummarizedExperiment*.

After introducing this, I'll motivate `tidyomics` as applied to
Bioconductor objects.

A *SummarizedExperiment* is built from three tables, which I will
demonstrate now:

```{r}
#| message: false
library(SummarizedExperiment)
# metadata about genes
genes <- DataFrame(
  id = c("g1","g2","g3","g4"), 
  symbol = c("ABC","DEF","GHI","JKL")
  )
genes
```

```{r}
# metadata about samples
samples <- DataFrame(
  sample = c("s1","s2","s3","s4"),
  condition = c("x","y","x","y"),
  sex = c("m","m","f","f")
  )
samples
```

```{r}
set.seed(123) # we will generate some random count data
counts <- matrix(rpois(16, lambda=100), ncol=4)
rownames(counts) <- genes$id
colnames(counts) <- samples$sample
counts
```

```{r}
se <- SummarizedExperiment(
  assays = list(counts = counts),
  rowData = genes, 
  colData = samples,
  metadata = list(organism="Hsapiens")
  )
se
```

## Objects help avoid common bookkeeping errors

Reordering samples (columns) is a global operation:

```{r}
se2 <- se[,c(1,3,2,4)]
assay(se2, "counts")
colData(se2)
```

Assignment that might result in sample swap results in an error:

```{r}
#| eval: false
assay(se2) <- counts
# Error:
# please use 'assay(x, withDimnames=FALSE)) <- value' or 
# 'assays(x, withDimnames=FALSE)) <- value'
# when the rownames or colnames of the supplied assay(s) are not 
# identical to those of the receiving  SummarizedExperiment object 'x'
```

Other such validity checks include comparison of genomic ranges across
different genome builds: will result in an error.

## However, may be hard for new users to get started

```{r}
slotNames(se)
methods(class = class(se))
```

## And yet, many beginners know dplyr and ggplot2

```{r}
#| message: false
library(dplyr)
# filter to samples in condition 'x'
samples |> 
  as_tibble() |> 
  filter(condition == "x")
```

## `tidyomics` enables dplyr verbs for omics objects

```{r}
#| message: false
library(tidySummarizedExperiment)
se
```

What does this mean "*SummarizedExperiment-tibble abstraction*"?

...put a drawing...

## This is still a standard Bioconductor object

```{r}
class(se)
dim(se)
```

## But we can use familiar dplyr verbs

```{r}
se |> 
  filter(condition == "x")
```

```{r}
se_sub <- se |> 
  filter(condition == "x")
colData(se_sub)
```

## Facilitates quick exploration and plotting

```{r ggplot}
#| message: false
library(ggplot2)
se |> 
  filter(.feature %in% c("g1","g2")) |> 
  ggplot(aes(condition, counts, color=sex, group=sex)) + 
  geom_point(size=2) + 
  geom_line() +
  facet_wrap(~.feature) +
  ylim(0,200) + 
  theme(text = element_text(size = 16))
```

```{r}
#| echo: false
options(dplyr.summarise.inform=FALSE)
```

```{r grouping-genes}
# suppose we had gene groups
rowData(se)$gene_group = c(1,1,2,2)
se |> 
  group_by(gene_group, sample, condition, sex) |> 
  summarize(ave_count = mean(counts), sd_count = sd(counts)) |> 
  ggplot(aes(condition, ave_count, 
             ymin=ave_count - 2*sd_count, 
             ymax=ave_count + 2*sd_count,
             color=sex, group=sex)) + 
  geom_pointrange(position = position_dodge(width = .25)) + 
  facet_wrap(~gene_group, labeller = "label_both") +
  ylim(0,200) + 
  theme(text = element_text(size = 16))
```
