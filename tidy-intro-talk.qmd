---
title: "Tidyomics: Enabling Tidy Data Analysis Workflows for Complex Biological Data"
author:
  - name: "Michael Love"
    affiliation: "Biostatistics & Genetics, UNC-Chapel Hill"
format: revealjs
self-contained: false
include-in-header:
  - text: |
      <style>
      #title-slide .title {
        font-size: 1.5em
      }
      </style>
---

## Tidyomics project

An open, open-source project spanning multiple R packages, and
developers from around the world. Operates within the Bioconductor
Project, with separate funding and organization. Coordination of
development via GitHub Projects.

-   <https://github.com/tidyomics>

-   [Announcement
    paper](https://www.biorxiv.org/content/10.1101/2023.09.10.557072v2)

-   `tidiness_in_bioc` channel in Bioconductor Slack

## Diagram of tidyomics workflows

![](figures/figure2.png){fig-align="center"
fig-alt="Diagram of how packages share a similar grammar to operate on data objects. From top to bottom, the data are analyzed, manipulated, and made into plots."}

## International development team

![](figures/tidyomics_community.png){fig-align="center" width="300"
fig-alt="Diagram of tidyomics community, with users and developers interacting. On the top are users with arrows coming from developers and packages. On the bottom is the extended community, including Bioconductor."}

## Keep data organized in *objects*

-   We typically have more information than just a matrix

-   Row and column information (on features and samples)

-   Annotated matrix data, i.e. python's `xarray`, `AnnData`

-   Metadata: organism, genome build, annotation release

-   2002: *ExpressionSet*; 2011: *SummarizedExperiment*

-   *Endomorphic functions*: `x |> f -> x`

## SummarizedExperiment, "SE"

A *SummarizedExperiment* is annotated matrix data:

```{r}
#| message: false
library(SummarizedExperiment)
set.seed(123) # some random count data
counts <- matrix(rpois(16, lambda=100), ncol=4)
rownames(counts) <- c("g1","g2","g3","g4")
colnames(counts) <- c("s1","s2","s3","s4")
counts
```

## Row data

```{r}
# metadata about genes (rows)
genes <- DataFrame(
  id = c("g1","g2","g3","g4"), 
  symbol = c("ABC","DEF","GHI","JKL")
  )
genes
```

## Column data

```{r}
# metadata about samples (columns)
samples <- DataFrame(
  sample = c("s1","s2","s3","s4"),
  condition = c("x","y","x","y"),
  sex = c("m","m","f","f")
  )
samples
```

## Assembled object

```{r}
se <- SummarizedExperiment(
  assays = list(counts = counts),
  rowData = genes, 
  colData = samples,
  metadata = list(organism="Hsapiens")
  )
se
```

## Avoids common bookkeeping errors

Reordering samples (columns) is a global operation:

```{r}
se2 <- se[,c(1,3,2,4)]
assay(se2, "counts")
colData(se2)
```

Assignment that might result in sample swap results in an error:

```{r}
#| eval: false
assay(se2) <- counts
# Error:
# please use 'assay(x, withDimnames=FALSE)) <- value' or 
# 'assays(x, withDimnames=FALSE)) <- value'
# when the rownames or colnames of the supplied assay(s) are not 
# identical to those of the receiving  SummarizedExperiment object 'x'
```

Other such validity checks include comparison of genomic ranges across
different genome builds: will result in an error.

## Can be hard for new users

```{r}
slotNames(se)
methods(class = class(se)) |> head(10)
```

## Many beginners know `dplyr`/`ggplot2`

```{r}
#| message: false
library(dplyr)
# filter to samples in condition 'x'
samples |> 
  as_tibble() |> 
  filter(condition == "x")
```

## Enabling dplyr verbs for omics

```{r}
#| message: false
library(tidySummarizedExperiment)
se
```

What does this mean "*SE-tibble abstraction*"?

Essentially this is an API, we can use our familiar verbs and interact
with the native object.

![](figures/counter.png){fig-alt="Picture of a counter with a menu and a bell"}

## Still a standard Bioc object

```{r}
class(se)
dim(se)
```

## We can use familiar dplyr verbs

```{r}
se |> 
  filter(condition == "x")
```

```{r}
se_sub <- se |> 
  filter(condition == "x")
colData(se_sub)
```

## Facilitates quick exploration

```{r}
#| message: false
#| echo: false
library(ggplot2)
theme_set(theme_grey(base_size = 16))
```

```{r ggplot}
#| message: false
library(ggplot2)
se |> 
  filter(.feature %in% c("g1","g2")) |> 
  ggplot(aes(condition, counts, color=sex, group=sex)) + 
  geom_point(size=2) + 
  geom_line() +
  facet_wrap(~.feature) +
  ylim(0,200)
```

## Works with Seurat and SCE

*SingleCellExperiment* = *SummarizedExperiment* with extra bells and
whistles for single cells. E.g. slots for reduced dimensions.

```{r umap}
#| eval: false
library(tidySingleCellExperiment)
library(scales)
sce <- readRDS("data/tidyomicsWorkshopSCE.rds")
sce |>
  filter(Phase == "G1") |>
  ggplot(aes(UMAP_1, UMAP_2, color=nCount_RNA)) +
  geom_point() + 
  scale_color_gradient2(trans="log10")
```

![](figures/umap-1.png)

## Efficient operation on SE with `plyxp`

```{r}
#| echo: false
#| message: false
library(SummarizedExperiment)
simple <- SummarizedExperiment(
  list(counts = matrix(1:12,nrow=3)),
  colData = data.frame(type = factor(c(1,1,2,2)), 
                       row.names = letters[1:4]),
  rowData = data.frame(length = c(10,20,30),
                       row.names = LETTERS[1:3])
)
```

```{r}
class(simple)
assay(simple)
colData(simple)
rowData(simple)
```

```{r}
#| message: false
library(plyxp)
xp <- simple |> 
  new_plyxp()
xp
```

```{r}
xp |> 
  mutate(norm_counts = counts / .rows$length)
```

```{r}
summed <- xp |>
  group_by(cols(type)) |>
  summarize(sum = rowSums(counts))
summed
assay(summed)
```

```{r}
class(xp)
colData(xp)
xp |> se()
```

## Computing on genomic ranges with tidy grammar

Nontrivial to translate biological or biomedical questions about the
genome into code. The tidy grammar helps in this case with familiar
concepts of filters, joins, grouping, mutation, or summarization.

![](figures/fillingthegaps.png){fig-alt="Source: 'Filling the Gaps', T2T Consoritium, Science."}

## Genomic overlap as a `join`

```{r}
#| echo: false
#| message: false
library(plyranges)
set.seed(5)
n <- 40
x <- data.frame(seqnames=1, start=round(runif(n, 101, 996)), 
                width=2, score=rnorm(n, mean=5)) |>
  as_granges() |>
  sort()
seqlengths(x) <- 1000
y <- data.frame(seqnames=1, start=c(101, 451, 801), 
                width=200, id = c("a","b","c")) |>
  as_granges()
```

```{r}
library(plyranges)
x
y
```

![](figures/woodjoin.png){fig-alt="Picture of two stacks of wood being interleaved"}

```{r}
x |> join_overlap_inner(y)
```

Many options, `directed`, `within`, `maxgap`, `minoverlap`, etc.

```{r}
# chaining operations
x |>
  filter(score > 3.5) |>
  join_overlap_inner(y) |>
  group_by(id) |>
  summarize(ave_score = mean(score), n = n())
```

```{r ranges-plot}
# pipe to plot
x |>
  filter(score > 3.5) |>
  join_overlap_inner(y) |>
  as_tibble() |>
  ggplot(aes(x = id, y = score)) + 
  geom_violin() + geom_jitter(width=.1)
```

```{r}
# many convenience functions
y |> 
  anchor_5p() |> # 5', 3', start, end, center
  mutate(width=2) |>
  join_nearest(x, distance=TRUE)
```

## Assess overlap significance using a tidy grammar

something

## nullranges for defining null genomic range sets

We developed a package
[nullranges](https://nullranges.github.io/nullranges), as a modular
tool to assist with making genomic comparisons. It doesn't do
enrichment analysis but provides null genomic range sets for
investigating various hypotheses.

## Bootstrapping ranges

Statistical papers from the ENCODE project noted that *block
bootstrapping* genomic data preserves important spatial patterns
(Bickel *et al.* 2010).

![](figures/boot.png){fig-alt="Diagram of block bootstrapping genomic ranges. Blocks are resampled from original data and arranged to form new range sets."}

```{r}
#| message: false
library(nullranges)
boot <- bootRanges(x, blockLength=10, R=20)
# keep track of bootstrap iteration, gives boot dist'n
boot |>
  join_overlap_inner(y) |>
  group_by(iter, id) |>
  summarize(n_overlaps = n())
```

```{r boot-plot}
boot |>
  join_overlap_inner(y) |>
  group_by(iter, id) |>
  summarize(n_overlaps = n()) |>
  as_tibble() |>
  ggplot(aes(x = id, y = n_overlaps)) + 
  geom_boxplot()
```

## Matching ranges

Matching on covariates from a large pool allows for more focused
hypothesis testing.

![](figures/match.png){fig-alt="Diagram of matching genomic ranges. A pool of different colored ranges are drawn from to match the warmer colors of a focal set of ranges."}

```{r match-covar-plot}
xprime <- x |>
  filter(score > 5) |>
  mutate(score = rnorm(n(), mean = score, sd = .5))
m <- matchRanges(focal = xprime, pool = x, covar = ~score)
plotCovariate(m)
```

```{r}
combined <- bind_ranges(
  focal = xprime,
  matching = matched(m),
  pool = x,
  .id = "origin"
)
combined
# now use the different sets for computation:
combined |> 
  join_overlap_inner(y) |>
  group_by(id, origin) |>
  summarize(ave_score = mean(score))
```

```{r match-overlap-plot}
combined |> 
  join_overlap_inner(y) |>
  group_by(id, origin) |>
  summarize(ave_score = mean(score), sd = sd(score)) |>
  as_tibble() |>
  ggplot(aes(origin, ave_score, 
             ymin=ave_score-2*sd, ymax=ave_score+2*sd)) + 
  geom_pointrange() +
  facet_wrap(~id, labeller = label_both)
```

These are published as Application Notes:

-   [bootRanges](https://doi.org/10.1093/bioinformatics/btad190)

-   [matchRanges](https://doi.org/10.1093/bioinformatics/btad197)

## Current state and future directions

something

## What has been implemented

-   Matrix-shaped objects (SE, SCE)

-   Ranges

-   Interactions

-   Cytometry

-   Spatial

-   more to come...

## Limitations

-   package code and *non-standard evaluation*
-   optimized code, e.g. matrix operations

## How to contribute

-   <https://github.com/tidyomics>, read docs, see open challenges

-   Motivation:
    <https://www.biorxiv.org/content/10.1101/2023.09.10.557072v2>

-   `tidiness_in_bioc` channel in Bioconductor Slack

## Outro

Omics data analysis means looking at:

-   main contributions to variance (e.g. PCA, see `plotPCA` for bulk
    and [OSCA](https://bioconductor.org/books/release/OSCA/) for sc),
    also `variancePartition`
-   column and row densities (`tidySE` allows directly plotting
    `geom_density` of rows/columns, or `geom_violin`)
-   known positive features, feature-level plots (`filter` to feature,
    pipe to `geom_point` etc.)

If you're interested in more complicated use cases of `tidyomics` see
this online book:

-   [Tidy ranges
    tutorial](https://tidyomics.github.io/tidy-ranges-tutorial)

## Contributors

-   Stefano Mangiola (*tidyomics* leadership, tidy expression, single
    cell, spatial)

-   Justin Landis (*plyxp*)

-   Eric Davis, Wancen Mu, Doug Phanstiel (*nullranges*)

-   Stuart Lee, Michael Lawrence, Di Cook (*plyranges*)

And **tidyomics developers**: William Hutchison, Timothy Keyes, Helena
Crowell, Jacques Serizay, Charlotte Soneson, Eric Davis, Noriaki Sato,
Lambda Moses, Boyd Tarlinton, Abdullah Nahid, Miha Kosmac, Quentin
Clayssen, Victor Yuan, Wancen Mu, Ji-Eun Park, Izabela Mamede, Min
Hyung Ryu, Pierre-Paul Axisa, Paulina Paiz, Chi-Lam Poon, Ming Tang

## Funding

*tidyomics* project funded by an Essential Open Source Software award
from CZI and Wellcome Trust
