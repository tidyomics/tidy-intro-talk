---
title: "Tidyomics: Enabling Tidy Data Analysis for Complex Biological Data"
author:
  - name: "Michael Love"
    affiliation: "Biostatistics & Genetics, UNC-Chapel Hill"
format: 
  revealjs:
    theme: simple
    slideNumber: true
    self-contained: false
    highlight-style: github
include-in-header:
  - text: |
      <style>
      #title-slide .title {
        font-size: 1.5em
      }
      </style>
---

## Tidyomics project

An open, open-source project spanning multiple R packages, and
developers from around the world. Operates within the Bioconductor
Project, with separate funding and organization. Coordination of
development via GitHub Projects.

-   <https://github.com/tidyomics>

-   [Announcement
    paper](https://www.biorxiv.org/content/10.1101/2023.09.10.557072v2)

-   `tidiness_in_bioc` channel in Bioconductor Slack

## Diagram of tidyomics workflows

![](figures/figure2.png){fig-align="center"
fig-alt="Diagram of how packages share a similar grammar="}

## International development team

![](figures/tidyomics_community.png){fig-align="center" width="300"
fig-alt="Diagram of tidyomics community="}

## Keep data organized in *objects*

-   We typically have more information than just a matrix

-   Row and column information (on features and samples)

-   Annotated matrix data, i.e. python's `xarray`, `AnnData`

-   Metadata: organism, genome build, annotation release

-   2002: *ExpressionSet*; 2011: *SummarizedExperiment*

-   *Endomorphic functions*: `x |> f -> x`

## SummarizedExperiment, "SE"

A *SummarizedExperiment* is annotated matrix data.

Imagine a matrix of counts:

```{r}
#| message: false
library(SummarizedExperiment)
set.seed(123) # some random count data
```

```{r}
#| echo: true
counts <- matrix(
  rpois(16, lambda=100), ncol=4,
  dimnames=list(c("g1","g2","g3","g4"),
                c("s1","s2","s3","s4"))
)
counts
```

## Row data

```{r}
# metadata about genes (rows)
genes <- DataFrame(
  id = c("g1","g2","g3","g4"), 
  symbol = c("ABC","DEF","GHI","JKL")
  )
genes
```

## Column data

```{r}
# metadata about samples (columns)
samples <- DataFrame(
  sample = c("s1","s2","s3","s4"),
  condition = c("x","y","x","y"),
  sex = c("m","m","f","f")
  )
samples
```

## Assembled object

```{r}
#| echo: true
se <- SummarizedExperiment(
  assays = list(counts = counts),
  rowData = genes, 
  colData = samples,
  metadata = list(organism="Hsapiens")
  )
se
```

## Deals with bookkeeping issues

Reordering samples (columns) is a global operation:

```{r}
#| echo: true
se2 <- se[,c(1,3,2,4)]
assay(se2, "counts")
colData(se2)
```

## Deals with bookkeeping issues

Assignment that might result in sample swap results in an error:

```{r}
#| echo: true
#| eval: false
assay(se2) <- counts
# Error:
# please use 'assay(x, withDimnames=FALSE)) <- value' or 
# 'assays(x, withDimnames=FALSE)) <- value'
# when the rownames or colnames of the supplied assay(s) are not 
# identical to those of the receiving  SummarizedExperiment object 'x'
```

-   Other such validity checks include comparison of genomic ranges
    across different genome builds.

-   Will result in an error.

## Can be a lot for new users

```{r}
slotNames(se)
methods(class = class(se)) |> head(10)
```

So while an advanced R/Bioconductor user should learn these methods,
maybe not needed to immediately explore or visualize data, make basic
data summaries.

## Beginners know `dplyr` & `ggplot2`

```{r}
#| echo: true
#| message: false
library(dplyr)
# filter to samples in condition 'x'
samples |> 
  as_tibble() |> 
  filter(condition == "x")
```

## Enabling dplyr verbs for omics

```{r}
#| echo: true
#| message: false
library(tidySummarizedExperiment)
se
```

What does this mean "*SE-tibble abstraction*"?

## Tidyomics is an API

We can use our familiar verbs and interact with the native
Bioconductor object using standard R/Bioconductor methods.

![](figures/counter.png){fig-alt="Counter with a menu and a bell"
fig-align="center"}

## Still a standard Bioc object

```{r}
#| echo: false
class(se)
dim(se)
```

## We can use familiar dplyr verbs

```{r}
#| echo: true
se |> 
  filter(condition == "x")
```

## We can use familiar dplyr verbs

```{r}
#| echo: true
se_sub <- se |> 
  filter(condition == "x")
colData(se_sub)
```

## Facilitates quick exploration

```{r}
#| message: false
#| echo: false
library(ggplot2)
theme_set(theme_grey(base_size = 16))
```

```{r ggplot}
#| message: false
#| echo: true
#| fig-align: center
library(ggplot2)
se |> 
  filter(.feature %in% c("g1","g2")) |> 
  ggplot(aes(condition, counts, color=sex, group=sex)) + 
  geom_point(size=2) + geom_line() +
  facet_wrap(~.feature) + ylim(0,200)
```

## Seurat and SingleCellExperiment

*SingleCellExperiment* = *SE* with slots for e.g. reduced dimensions.

```{r}
#| eval: false
#| echo: false
library(tidySingleCellExperiment)
library(scales)
sce <- readRDS("data/tidyomicsWorkshopSCE.rds")
```

```{r umap}
#| eval: false
#| echo: true
sce |>
  filter(Phase == "G1") |>
  ggplot(aes(UMAP_1, UMAP_2, color=nCount_RNA)) +
  geom_point() + scale_color_gradient2(trans="log10")
```

![](figures/umap-1.png){fig-align="center"}

## Efficient operation on SE with `plyxp`

```{r}
#| echo: false
#| message: false
library(SummarizedExperiment)
simple <- SummarizedExperiment(
  list(counts = matrix(1:12,nrow=3)),
  colData = data.frame(type = factor(c(1,1,2,2)), 
                       row.names = letters[1:4]),
  rowData = data.frame(length = c(10,20,30),
                       row.names = LETTERS[1:3])
)
```

## Efficient operation on SE with `plyxp`

```{r}
#| echo: true
assay(simple)
colData(simple)
rowData(simple)
```

## Specifying \`plyxp\` methods

```{r}
#| echo: true
#| message: false
library(plyxp)
xp <- simple |> 
  new_plyxp()
xp
```

## Mutate with `plyxp`

```{r}
#| echo: true
xp |> 
  mutate(norm_counts = counts / .rows$length)
```

## Grammar for group and summarize

```{r}
#| echo: true
summed <- xp |>
  group_by(cols(type)) |>
  summarize(sum = rowSums(counts))
summed
assay(summed)
```

## Unspecifying `plyxp`

```{r}
#| echo: true
class(xp)
colData(xp)
xp |> se()
```

## Computing on genomic ranges

-   Translate biological or biomedical questions about the genome into
    code.

-   Leverage familiar concepts of filters, joins, grouping, mutation,
    or summarization.

![](figures/fillingthegaps.png){fig-alt="T2T Consoritium, Science."
fig-align="center"}

## Genomic overlap as a join

![](figures/woodjoin.png){fig-alt="Interwoven stacks of wood"}

```{r}
#| echo: false
#| message: false
library(plyranges)
set.seed(5)
n <- 40
x <- data.frame(seqnames=1, start=round(runif(n, 101, 996)), 
                width=2, score=rnorm(n, mean=5)) |>
  as_granges() |>
  sort()
seqlengths(x) <- 1000
y <- data.frame(seqnames=1, start=c(101, 451, 801), 
                width=200, id = c("a","b","c")) |>
  as_granges()
```

## Genomic overlap as a join

```{r}
#| echo: true
#| message: false
library(plyranges)
x
```

## Genomic overlap as a join

```{r}
#| echo: true
y
```

## Computing overlap (here inner join)

```{r}
#| echo: true
x |> join_overlap_inner(y)
```

## Options

`directed`, `within`, `maxgap`, `minoverlap`, etc.

```{r}
#| echo: true
# chaining operations
x |>
  filter(score > 3.5) |>
  join_overlap_inner(y) |>
  group_by(id) |>
  summarize(ave_score = mean(score), n = n())
```

## Pipe to plot

```{r ranges-plot}
#| echo: true
#| fig-align: center
# pipe to plot
x |>
  filter(score > 3.5) |>
  join_overlap_inner(y) |>
  as_tibble() |>
  ggplot(aes(x = id, y = score)) + 
  geom_violin() + geom_jitter(width=.1)
```

## Convenience functions

```{r}
#| echo: true
# many convenience functions
y |> 
  anchor_5p() |> # 5', 3', start, end, center
  mutate(width=2) |>
  join_nearest(x, distance=TRUE)
```

## Assess overlap significance using a tidy grammar

something here

## Defining null genomic range sets

-   We developed a package
    [nullranges](https://nullranges.github.io/nullranges), as a
    modular tool to assist with making genomic comparisons.

-   No enrichment analysis but provides null genomic range sets for
    investigating various hypotheses.

## Bootstrapping ranges

Statistical papers from the ENCODE project noted that *block
bootstrapping* genomic data preserves important spatial patterns
(Bickel *et al.* 2010).

![](figures/boot.png){fig-alt="Diagram of block bootstrapping"
fig-align="center"}

## bootRanges

```{r}
#| echo: true
#| message: false
library(nullranges)
boot <- bootRanges(x, blockLength=10, R=20)
# keep track of bootstrap iteration, gives boot dist'n
boot |>
  join_overlap_inner(y) |>
  group_by(iter, id) |>
  summarize(n_overlaps = n())
```

## bootRanges

```{r boot-plot}
#| echo: true
#| fig-align: center
boot |>
  join_overlap_inner(y) |>
  group_by(iter, id) |>
  summarize(n_overlaps = n()) |>
  as_tibble() |>
  ggplot(aes(x = id, y = n_overlaps)) + 
  geom_boxplot()
```

## Matching ranges

Matching on covariates from a large pool allows for more focused
hypothesis testing.

![](figures/match.png){fig-alt="Diagram of matching genomic ranges"
fig-align="center"}

## matchRanges

```{r match-covar-plot}
#| echo: true
#| fig-align: center
xprime <- x |>
  filter(score > 5) |>
  mutate(score = rnorm(n(), mean = score, sd = .5))
m <- matchRanges(focal = xprime, pool = x, covar = ~score)
plotCovariate(m)
```

## Group and summarize

```{r}
#| echo: true
combined <- bind_ranges(
  focal = xprime,
  matching = matched(m),
  pool = x,
  .id = "origin"
)
# now use the different sets for computation:
combined |> 
  join_overlap_inner(y) |>
  group_by(id, origin) |>
  summarize(ave_score = mean(score))
```

## Pipe to plot

```{r match-overlap-plot}
#| echo: true
#| fig-align: center
combined |> 
  join_overlap_inner(y) |>
  group_by(id, origin) |>
  summarize(ave_score = mean(score), sd = sd(score)) |>
  as_tibble() |>
  ggplot(aes(origin, ave_score, 
             ymin=ave_score-2*sd, ymax=ave_score+2*sd)) + 
  geom_pointrange() +
  facet_wrap(~id, labeller = label_both)
```

## bootRanges and matchRanges methods

These are published as Application Notes:

-   [bootRanges](https://doi.org/10.1093/bioinformatics/btad190)

-   [matchRanges](https://doi.org/10.1093/bioinformatics/btad197)

## Current state and future directions

something

## What has been implemented

Put people's packages names etc.

-   Matrix-shaped objects (SE, SCE)

-   Ranges

-   Interactions

-   Cytometry

-   Spatial

-   more to come...

## Limitations

-   package code and *non-standard evaluation*
-   optimized code, e.g. matrix operations

## How to contribute

-   <https://github.com/tidyomics>, read docs, see open challenges

-   Motivation:
    <https://www.biorxiv.org/content/10.1101/2023.09.10.557072v2>

-   `tidiness_in_bioc` channel in Bioconductor Slack

## Outro

Omics data analysis means looking at:

-   main contributions to variance (e.g. PCA, see `plotPCA` for bulk
    and [OSCA](https://bioconductor.org/books/release/OSCA/) for sc),
    also `variancePartition`
-   column and row densities (`tidySE` allows directly plotting
    `geom_density` of rows/columns, or `geom_violin`)
-   known positive features, feature-level plots (`filter` to feature,
    pipe to `geom_point` etc.)

If you're interested in more complicated use cases of `tidyomics` see
this online book:

-   [Tidy ranges
    tutorial](https://tidyomics.github.io/tidy-ranges-tutorial)

## Contributors

-   Stefano Mangiola (*tidyomics* leadership, tidy expression, single
    cell, spatial)

-   Justin Landis (*plyxp*)

-   Eric Davis, Wancen Mu, Doug Phanstiel (*nullranges*)

-   Stuart Lee, Michael Lawrence, Di Cook (*plyranges*)

And **tidyomics developers**: William Hutchison, Timothy Keyes, Helena
Crowell, Jacques Serizay, Charlotte Soneson, Eric Davis, Noriaki Sato,
Lambda Moses, Boyd Tarlinton, Abdullah Nahid, Miha Kosmac, Quentin
Clayssen, Victor Yuan, Wancen Mu, Ji-Eun Park, Izabela Mamede, Min
Hyung Ryu, Pierre-Paul Axisa, Paulina Paiz, Chi-Lam Poon, Ming Tang

## Funding

*tidyomics* project funded by an Essential Open Source Software award
from CZI and Wellcome Trust
